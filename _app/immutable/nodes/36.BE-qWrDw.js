import"../chunks/Bzak7iHL.js";import"../chunks/kfVmCPsV.js";import{p as C,g as F,d as J,b as N,s as o,f as P,e,t as W,a as X,r as t,n as H}from"../chunks/C2PHntuy.js";import{h as I}from"../chunks/C3QlhiH-.js";import{s}from"../chunks/CEusTUg_.js";import{i as M}from"../chunks/BQOOHHT8.js";import{l as O,s as Y}from"../chunks/gzNpScmH.js";import{B as Z}from"../chunks/B1caYEk9.js";import{t as G}from"../chunks/C3bQ3Oc7.js";const S=""+new URL("../assets/ast-explorer.DbZdyVuy.png",import.meta.url).href,K=""+new URL("../assets/ast-explorer.DSfXiE1T.png",import.meta.url).href,Q=""+new URL("../assets/ast-explorer.D_-aEESM.webp",import.meta.url).href,ee=""+new URL("../assets/ast-explorer.BNNA6sF1.webp",import.meta.url).href,T=""+new URL("../assets/flow-ast.D0rBzaD_.png",import.meta.url).href,te=""+new URL("../assets/flow-ast.0mVXTJVH.png",import.meta.url).href,se=""+new URL("../assets/flow-ast.AtJjr9i6.webp",import.meta.url).href,oe=""+new URL("../assets/flow-ast.f7bUm6eq.webp",import.meta.url).href,D=""+new URL("../assets/babel-eslint-8-ast.CTVD2_2p.png",import.meta.url).href,ae=""+new URL("../assets/babel-eslint-8-ast.7XNrbKA0.png",import.meta.url).href,re=""+new URL("../assets/babel-eslint-8-ast.j_B8lCLF.webp",import.meta.url).href,ie=""+new URL("../assets/babel-eslint-8-ast.DP6U0ADl.webp",import.meta.url).href,A=""+new URL("../assets/flow-ast.D0rBzaD_.png",import.meta.url).href,ne=""+new URL("../assets/flow-ast.0mVXTJVH.png",import.meta.url).href,le=""+new URL("../assets/flow-ast.AtJjr9i6.webp",import.meta.url).href,pe=""+new URL("../assets/flow-ast.f7bUm6eq.webp",import.meta.url).href,B={title:"My eslint doesn‚Äôt work with for flow 0.85‚Äôs explicit type argument syntax",date:"2019-01-17T08:00:00Z",description:"and how I figured out why.",label:"blog"},{title:ve,date:ke,description:xe,label:$e}=B;var ce=N('<p>Today <a href="https://dev.wgao19.cc/" rel="nofollow">Wei Gao</a> posed an interesting question:</p> <p>She was upgrading Flow to v0.85, <a href="https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8" rel="nofollow">which requires her to explicitly type the argument of the function call</a>. However, when she saved the file, our <a href="https://github.com/prettier/prettier" rel="nofollow">eslint-prettier</a> automatically format the code into a weird syntax:</p> <p>So, when she wrote:</p> <div class="code-section"><!></div> <p>With <a href="https://github.com/prettier/eslint-plugin-prettier" rel="nofollow">eslint-plugin-prettier</a>, eslint <em>‚Äúfixed‚Äù</em> the code into:</p> <div class="code-section"><!></div> <p>It felt like eslint sees <code class="inline">&lt;</code> and <code class="inline">&gt;</code> as the comparison operator, rather than <code class="inline">&lt;Type&gt;</code> as a whole!</p> <p>To confirm with my hypothesis, I opened up my favourite tool for inspecting <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="nofollow">AST</a>: <a href="https://astexplorer.net/" rel="nofollow">astexplorer.net</a></p> <hr/> <p>You can paste your code into <a href="https://astexplorer.net/" rel="nofollow">astexplorer.net</a> and see how different parser ‚Äúsees‚Äù your code in terms of a AST (Abstract Syntax Tree).</p> <p><span style="display: block; position: relative; padding-top: 57.183%; width: 100%;"><picture><source type="image/webp"/><img loading="lazy" style="position: absolute; top: 0; width: 100%; height: 100%" alt="You can choose different a parser!"/></picture></span></p> <p>As you can see from the picture above, you can choose from different parsers:</p> <ul><li><strong>acorn</strong>‚Ää‚Äî‚Ääthe parser used by webpack after the loaders, webpack uses acorn‚Äôs AST to find <code class="inline">import</code> and <code class="inline">require()</code> syntax to know generate the dependency tree of your project, as well as provide an entry for plugins like <a href="https://webpack.js.org/plugins/define-plugin/" rel="nofollow">DefinePlugin</a> to transform the transpiled code.</li> <li><strong>babylon</strong>‚Äî‚Ääthe <a href="https://github.com/babel/babel/" rel="nofollow">babel</a> parser, now it‚Äôs called <a href="https://babeljs.io/docs/en/babel-parser" rel="nofollow">@babel/parser</a>.</li> <li><strong>flow</strong>, <strong>typescript</strong>, <strong>uglify-js</strong>‚Äî‚Ääthe parsers that each of the library uses</li> <li><strong>esprima</strong>‚Ää‚Äî‚Ääthe default eslint parser</li> <li><strong>babel-eslint</strong>‚Ää‚Äî‚Ääa wrapper of babel parser for eslint, which is also the one we used, because we have a ton of babel plugins configured, so by using babel-eslint we don‚Äôt have to reconfigure the same plugins for eslint.</li></ul> <hr/> <p>So I copied our code into astexplorer, and selected the ‚Äúflow‚Äù parser:</p> <p><span style="display: block; position: relative; padding-top: 28.927%; width: 100%;"><picture><source type="image/webp"/><img loading="lazy" style="position: absolute; top: 0; width: 100%; height: 100%" alt="flow ast"/></picture></span></p> <p>I can see the type annotation is being parsed as ‚ÄúTypeParameterInstantiation‚Äù, however when I changed the parser to ‚Äúbabel-eslint8‚Äù,</p> <p><span style="display: block; position: relative; padding-top: 39.444%; width: 100%;"><picture><source type="image/webp"/><img loading="lazy" style="position: absolute; top: 0; width: 100%; height: 100%" alt="babel eslint 8 ast"/></picture></span></p> <p>I get a Binary Expression and a SequenceExpression!</p> <hr/> <p><strong>Binary Expression</strong> is a way to express logical expression and mathematical expression, eg: <code class="inline">a + b</code> , <code class="inline">a && b</code> , <code class="inline">a &lt;= b</code>, etc.</p> <p><strong>Sequence Expression</strong> on the other hand is something you don‚Äôt see people write that often, you can look up how it works in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator" rel="nofollow">Comma operator (MDN)</a>, basically you can write expressions as a expression by joining them with a comma operator (<code class="inline">,</code>), and the expression returns the value of the last expression, eg: result = <code class="inline">(a++, b++, c -= 2, d.push(e), --f)</code>, you increment <code class="inline">a</code> , <code class="inline">b</code> , decrement <code class="inline">c</code> by 2, and pushed <code class="inline">e</code> into <code class="inline">d</code> and decrement <code class="inline">f</code> and set result to the new value of <code class="inline">f</code>. Wow, that‚Äôs a lot in one statement! It‚Äôs confusing to read, but you see this often in a minified code.</p> <hr/> <p>Now this explains why prettier will try to add space in between <code class="inline">&lt;</code> and <code class="inline">&gt;</code> .</p> <p>I saw that there‚Äôs a babel-eslint9, and I gave it a try, and‚Ä¶</p> <p><span style="display: block; position: relative; padding-top: 28.927%; width: 100%;"><picture><source type="image/webp"/><img loading="lazy" style="position: absolute; top: 0; width: 100%; height: 100%" alt="babel eslint 9 ast"/></picture></span></p> <p>It seems like the bug was fixed on <code class="inline">babel-eslint9</code>, so I plowed through the release notes of babel-eslint, and I found this <a href="https://github.com/babel/babel-eslint/pull/444" rel="nofollow">merge commit</a>. So it seems like upgrading babel-eslint to v9 will solve the issue! üéâ</p>',1);function Ue(j,p){const q=O(p,["children","$$slots","$$events","$$legacy"]);C(p,!1),F("blog",{image:G}),M(),Z(j,Y(()=>q,()=>B,{children:(z,de)=>{var c=ce(),a=o(P(c),6),E=e(a);I(E,()=>'<pre class="shiki" style="background-color: var(--shiki-color-background)"><code><span class="line"><span style="color: var(--shiki-token-function)">fooFunction</span><span style="color: var(--shiki-color-text)">&lt;</span><span style="color: var(--shiki-token-function)">Bar</span><span style="color: var(--shiki-color-text)">&gt;(</span><span style="color: var(--shiki-token-constant)">1</span><span style="color: var(--shiki-token-punctuation)">,</span><span style="color: var(--shiki-color-text)"> </span><span style="color: var(--shiki-token-constant)">2</span><span style="color: var(--shiki-token-punctuation)">,</span><span style="color: var(--shiki-color-text)"> </span><span style="color: var(--shiki-token-constant)">3</span><span style="color: var(--shiki-color-text)">);</span></span></code></pre>'),t(a);var r=o(a,4),V=e(r);I(V,()=>'<pre class="shiki" style="background-color: var(--shiki-color-background)"><code><span class="line"><span style="color: var(--shiki-token-function)">fooFunction</span><span style="color: var(--shiki-color-text)"> &lt; </span><span style="color: var(--shiki-token-function)">Bar</span><span style="color: var(--shiki-color-text)"> &gt; (</span><span style="color: var(--shiki-token-constant)">1</span><span style="color: var(--shiki-token-punctuation)">,</span><span style="color: var(--shiki-color-text)"> </span><span style="color: var(--shiki-token-constant)">2</span><span style="color: var(--shiki-token-punctuation)">,</span><span style="color: var(--shiki-color-text)"> </span><span style="color: var(--shiki-token-constant)">3</span><span style="color: var(--shiki-color-text)">);</span></span></code></pre>'),t(r);var i=o(r,10),d=e(i),h=e(d),u=e(h),m=o(u);t(h),t(d),t(i);var n=o(i,10),b=e(n),_=e(b),f=e(_),g=o(f);t(_),t(b),t(n);var l=o(n,4),w=e(l),y=e(w),v=e(y),k=o(v);t(y),t(w),t(l);var x=o(l,16),$=e(x),U=e($),L=e(U),R=o(L);t(U),t($),t(x),H(2),W(()=>{s(u,"srcset",`${Q}, ${ee} 2x`),s(m,"src",S),s(m,"srcset",`${S}, ${K} 2x`),s(f,"srcset",`${se}, ${oe} 2x`),s(g,"src",T),s(g,"srcset",`${T}, ${te} 2x`),s(v,"srcset",`${re}, ${ie} 2x`),s(k,"src",D),s(k,"srcset",`${D}, ${ae} 2x`),s(L,"srcset",`${le}, ${pe} 2x`),s(R,"src",A),s(R,"srcset",`${A}, ${ne} 2x`)}),X(z,c)},$$slots:{default:!0}})),J()}export{Ue as component};
