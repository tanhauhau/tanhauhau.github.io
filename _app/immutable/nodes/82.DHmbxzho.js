import{s as x,d as p,e as k,f as g,n as $}from"../chunks/scheduler.D6VJxl8L.js";import{S as j,i as C,m as L,n as M,o as I,t as P,a as T,p as H,e as d,s as v,c as f,q as h,h as w,j as u,g as m}from"../chunks/index.CLAVN-Y5.js";import{g as q,a as y}from"../chunks/code-snippet.Gym6WUAG.js";import{B}from"../chunks/BlogLayout.BLHkC4CD.js";import{t as D}from"../chunks/twitter-card-image.C3bQ3Oc7.js";function S(r){let e,l='<a href="https://martinfowler.com/articles/micro-frontends.html" rel="nofollow">https://martinfowler.com/articles/micro-frontends.html</a>',a,s,t="Problems:",o,i,_='<li><p>If router is asynchronously injected, what should you do when visit a route that is <strong>not yet injected</strong>?</p> <ul><li>Define a routing schema, eg, when you are visiting <code class="inline">/foo/bar</code> and your local routing registry does not contain the path, you should visit a predefine location for the script/manifest, eg: <code class="inline">server.com/sites/foo-bar/manifest.json</code>, and load the script. If there&#39;s no such file, it meant there&#39;s no such path.</li></ul></li> <li><p>Multiple webpack built runtime</p> <ul><li>async chunks will rely on the <code class="inline">window[&#39;webpackJsonp&#39;]</code> to <code class="inline">require</code> and <code class="inline">exports</code> module.</li> <li>multiple webpack built may have conflicting <code class="inline">chunkIds</code></li> <li>thankfully this can be solved via <a href="https://github.com/darshanlsagar/webpack-custom-chunk-id-plugin" rel="nofollow">webpack-custom-chunk-id-plugin</a></li></ul></li>';return{c(){e=d("p"),e.innerHTML=l,a=v(),s=d("p"),s.textContent=t,o=v(),i=d("ul"),i.innerHTML=_},l(n){e=f(n,"P",{"data-svelte-h":!0}),h(e)!=="svelte-5951ov"&&(e.innerHTML=l),a=w(n),s=f(n,"P",{"data-svelte-h":!0}),h(s)!=="svelte-1n10xu2"&&(s.textContent=t),o=w(n),i=f(n,"UL",{"data-svelte-h":!0}),h(i)!=="svelte-hhbo2g"&&(i.innerHTML=_)},m(n,c){u(n,e,c),u(n,a,c),u(n,s,c),u(n,o,c),u(n,i,c)},p:$,d(n){n&&(m(e),m(a),m(s),m(o),m(i))}}}function J(r){let e,l;const a=[r[0],b];let s={$$slots:{default:[S]},$$scope:{ctx:r}};for(let t=0;t<a.length;t+=1)s=p(s,a[t]);return e=new B({props:s}),{c(){L(e.$$.fragment)},l(t){M(e.$$.fragment,t)},m(t,o){I(e,t,o),l=!0},p(t,[o]){const i=o&1?q(a,[o&1&&y(t[0]),o&0&&y(b)]):{};o&2&&(i.$$scope={dirty:o,ctx:t}),e.$set(i)},i(t){l||(P(e.$$.fragment,t),l=!0)},o(t){T(e.$$.fragment,t),l=!1},d(t){H(e,t)}}}const b={title:"Thoughts on Micro-frontends",tags:["micro-frontend"],description:"https://martinfowler.com/articles/micro-frontends.htmlProblems:If router is asynchronously injected, what should you do when visit a route that is not yet injected?Define a routing schema, eg, when you are visiting ..."};function U(r,e,l){return k("blog",{image:D}),r.$$set=a=>{l(0,e=p(p({},e),g(a)))},e=g(e),[e]}class K extends j{constructor(e){super(),C(this,e,U,J,x,{})}}export{K as component};
